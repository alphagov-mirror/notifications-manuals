{
    "docs": [
        {
            "location": "/", 
            "text": "GOV.UK Notify Team Manuals\n\n\nThis is primarily for the benefit of team members, rather than users of the platform.\n\n\nProject\n: GOV.UK Notify\n\n\nProject website\n: https://www.notifications.service.gov.uk/\n\n\nOnboarding\n\n\n\n\nNotify-wiki\n\n\nDev getting start guide\n\n\n\n\nTeam Links\n\n\n\n\nPivotal Storyboard\n\n\nTech Debt Board\n\n\nJenkins tools\n\n\nNotify Preview\n\n\nNotify Staging\n\n\nNotify Live\n\n\nLogit.io Kibana Monitoring - natvigated from your gmail account-\ntoolbar\n\n\nHostedGraphite monitoring\n\n\n\n\nOther technical documents\n\n\n\n\nGoogle drive Notify Folder\n\n\n\n\nSome Tools\n\n\n\n\nDbeaver\n - database visualisation tool\n\n\nmacDown\n - Markdown editor \nbrew cask install markdown", 
            "title": "Home"
        }, 
        {
            "location": "/#govuk-notify-team-manuals", 
            "text": "This is primarily for the benefit of team members, rather than users of the platform.  Project : GOV.UK Notify  Project website : https://www.notifications.service.gov.uk/", 
            "title": "GOV.UK Notify Team Manuals"
        }, 
        {
            "location": "/#onboarding", 
            "text": "Notify-wiki  Dev getting start guide", 
            "title": "Onboarding"
        }, 
        {
            "location": "/#team-links", 
            "text": "Pivotal Storyboard  Tech Debt Board  Jenkins tools  Notify Preview  Notify Staging  Notify Live  Logit.io Kibana Monitoring - natvigated from your gmail account- toolbar  HostedGraphite monitoring", 
            "title": "Team Links"
        }, 
        {
            "location": "/#other-technical-documents", 
            "text": "Google drive Notify Folder", 
            "title": "Other technical documents"
        }, 
        {
            "location": "/#some-tools", 
            "text": "Dbeaver  - database visualisation tool  macDown  - Markdown editor  brew cask install markdown", 
            "title": "Some Tools"
        }, 
        {
            "location": "/systems/", 
            "text": "GOV.UK Notify Systems Overview\n\n\nSystem Context/Boundary\n\n\n\n\nNotify provides a service for Government Departments to send notifications to their end users. Hence, our 'users' are usually the Government departments rather than the end users. We provide 3 type of services: email, text messaging and letters (available soon).  \n\n\nThis system context/boundary diagram shows where external users and systems interact with Notify's backend systems. The interaction points are as follow:\n\n\nLeft side/ Inbound interactions\n\n\n\n\nUsers use Notify's \nadmin\n console webpages, which interacts with Notify backend systems via REST-API. The admin console can be used to \n\n\nupload and/or schedule csv jobs\n\n\nsend test notifications\n\n\nview outbound and inbound sms messages sent\n\n\nchange settings \n\n\nview billing and status information. \n\n\n\n\n\n\nUsers can programmatically interacts with our system via REST-API for uploading jobs for all \nemail\n, \nsms\n and \nletter\n services. \n\n\n\n\nRight side/ Outbound Interactions\n\n\nNotify provides a service for Government Departments to send notifications to their end users. Hence, our 'users' are usually the Government departments rather than the end users. We provide 3 type of services: email, text messaging and letters (available soon).\nThis system context/boundary diagram shows where external users and systems interact with Notify's backend systems. The interaction points are as follow:\n\n\n\n\nNotify interacts bi-directionaly with our SMS providers via REST-API. The SMS providers provide \ntext messages\n services for our users to send messages to their end users. We provide \ninbound sms\n service for our end-users to reply messages. \n\n\nNotify interacts with our \nemail\n service provider via AWS SES and SNS. The status of emails are sent back to our system via REST API\n\n\nNotify interacts with our AWS FTP server via boto3 and REST API, which allows DVLA (our letter service provider) to send and receive documents using ftp, for \nletter services\n. DVLA currently handles the posting of the letters.", 
            "title": "System Overview"
        }, 
        {
            "location": "/systems/#govuk-notify-systems-overview", 
            "text": "", 
            "title": "GOV.UK Notify Systems Overview"
        }, 
        {
            "location": "/systems/#system-contextboundary", 
            "text": "Notify provides a service for Government Departments to send notifications to their end users. Hence, our 'users' are usually the Government departments rather than the end users. We provide 3 type of services: email, text messaging and letters (available soon).    This system context/boundary diagram shows where external users and systems interact with Notify's backend systems. The interaction points are as follow:", 
            "title": "System Context/Boundary"
        }, 
        {
            "location": "/systems/#left-side-inbound-interactions", 
            "text": "Users use Notify's  admin  console webpages, which interacts with Notify backend systems via REST-API. The admin console can be used to   upload and/or schedule csv jobs  send test notifications  view outbound and inbound sms messages sent  change settings   view billing and status information.     Users can programmatically interacts with our system via REST-API for uploading jobs for all  email ,  sms  and  letter  services.", 
            "title": "Left side/ Inbound interactions"
        }, 
        {
            "location": "/systems/#right-side-outbound-interactions", 
            "text": "Notify provides a service for Government Departments to send notifications to their end users. Hence, our 'users' are usually the Government departments rather than the end users. We provide 3 type of services: email, text messaging and letters (available soon).\nThis system context/boundary diagram shows where external users and systems interact with Notify's backend systems. The interaction points are as follow:   Notify interacts bi-directionaly with our SMS providers via REST-API. The SMS providers provide  text messages  services for our users to send messages to their end users. We provide  inbound sms  service for our end-users to reply messages.   Notify interacts with our  email  service provider via AWS SES and SNS. The status of emails are sent back to our system via REST API  Notify interacts with our AWS FTP server via boto3 and REST API, which allows DVLA (our letter service provider) to send and receive documents using ftp, for  letter services . DVLA currently handles the posting of the letters.", 
            "title": "Right side/ Outbound Interactions"
        }, 
        {
            "location": "/security/", 
            "text": "Security", 
            "title": "Security"
        }, 
        {
            "location": "/security/#security", 
            "text": "", 
            "title": "Security"
        }, 
        {
            "location": "/incidents/", 
            "text": "Incidents reports\n\n\n(Requires GDS Access for viewing the reports)\n\n\n\n\n\n\n\n\nDate\n\n\nProblem (click for full report)\n\n\nSymptoms\n\n\nTag\n\n\n\n\n\n\n\n\n\n\n2017/10/09\n\n\n2FA sms stops to send\n\n\nError messages appear locally when running after a DB upgrade\n\n\nDB migratiaon\n\n\n\n\n\n\n2017/10/05\n\n\nJenkins out of memory\n\n\nJenkins builts fail + run out of disk space error appears in full build log\n\n\nJenkins\n\n\n\n\n\n\n2017/07/25\n\n\nAWS internet connectivity outage\n\n\nPacket loss on the Internet\n\n\nPaaS\n\n\n\n\n\n\n2016/08/05\n\n\nDatabase mismatch\n\n\nService Downtime during a deploy\n\n\nDB", 
            "title": "Incidents"
        }, 
        {
            "location": "/incidents/#incidents-reports", 
            "text": "(Requires GDS Access for viewing the reports)     Date  Problem (click for full report)  Symptoms  Tag      2017/10/09  2FA sms stops to send  Error messages appear locally when running after a DB upgrade  DB migratiaon    2017/10/05  Jenkins out of memory  Jenkins builts fail + run out of disk space error appears in full build log  Jenkins    2017/07/25  AWS internet connectivity outage  Packet loss on the Internet  PaaS    2016/08/05  Database mismatch  Service Downtime during a deploy  DB", 
            "title": "Incidents reports"
        }, 
        {
            "location": "/Dbeaver/", 
            "text": "Dbeaver\n\n\nThis document describes how to connect to the local database using Dbeaver, and create a read-only connection to the produciton database. \n\n\nLocal database connection\n\n\n\n\nCreate a new connection. Use these configurations\n\n\n\nThe tables are visible under Schemas/public/Tables\n\n\n\n\n\nCreate a read-only conneciton to database on server\n\n\n\n\nYou need to establish a database connection from shell. Following the procedure in this documentation, you create an SSH tunnel to our server - \nPaaS Note\n\n\nFrom Dbeaver, make a new database connection\n\n\nSelect postgres as connection type \n\n\nEnter the parameters and credentails for this connection. The port should be 15432 as the SSH tunnel you created in step 1. The database name and credentials can be found in Notify's credentail in /credentail/pass/postgres_logins.txt \n\n\nClick Next\n\n\nEnter SSL information as this", 
            "title": "Dbeaver"
        }, 
        {
            "location": "/Dbeaver/#dbeaver", 
            "text": "This document describes how to connect to the local database using Dbeaver, and create a read-only connection to the produciton database.", 
            "title": "Dbeaver"
        }, 
        {
            "location": "/Dbeaver/#local-database-connection", 
            "text": "Create a new connection. Use these configurations  The tables are visible under Schemas/public/Tables", 
            "title": "Local database connection"
        }, 
        {
            "location": "/Dbeaver/#create-a-read-only-conneciton-to-database-on-server", 
            "text": "You need to establish a database connection from shell. Following the procedure in this documentation, you create an SSH tunnel to our server -  PaaS Note  From Dbeaver, make a new database connection  Select postgres as connection type   Enter the parameters and credentails for this connection. The port should be 15432 as the SSH tunnel you created in step 1. The database name and credentials can be found in Notify's credentail in /credentail/pass/postgres_logins.txt   Click Next  Enter SSL information as this", 
            "title": "Create a read-only conneciton to database on server"
        }, 
        {
            "location": "/autoscaling/", 
            "text": "GOV.UK Notify AutoScaler\n\n\nNotify has bursty, periodic loads and traffic. Outside of that, the traffic stays low and, most of the time, it consists of scheduled test jobs.; and twe get more traffic during office hours. Once in a while, we would receive a task that is consisted of \n20k notifications. This has motivated us to develop an autoscaler to response to these tasks and scale up and down Notify apps instances running on PaaS. \n\n\nThese terms used in this article refer to:\n\n\n\n\na \njob\n is used to describe when a user uploads a csv file that consists of a batch of notifications to be sent \n\n\na \ntask\n is a unit of notification, database query or a process to be run on the servers at a time\n\n\na \nrequest\n describes an 'http request' to retrieve or process information.  \n\n\n\n\nMetrics\n\n\nNotify's auto scaling uses these metrics:\n\n\n\n\n\n\nRequestCounts (for Request handlers)\n \n\nA metric returned by AWS Cloudwatch for the Elastic Load Balancers (ELB) to scale each of the ELB apps running on PaaS\n\n\n\n\n\n\nApproximateNumberOfMessages (for Delivery workers)\n \n\nA metric returned by AWS Cloudwatch for the SQS queues to scale each notification delivery and database apps on PaaS.\n\n\n\n\n\n\nNumber of scheduled notifications (for Scheduled jobs)\n\nA metric obtained from the database for csv files to be sent in the next 1 minutes, and is updated everytime when the autoscaler is scheduled run.\n\n\n\n\n\n\nThe autoscaler is scheduled to run every 20 seconds using the python \nsched\n module. Autoscaling applies to each individual apps. \n\n\nScaling instances\n\n\nA factor \ndesired_instances_count\n is used to determine the desired number of instances to run for an App at an evaluated period. This factor is calculated differently for our three types of apps and is bounded by:\n\n\nmin_instance_count\n=desired_instances_count\n=max_instance_count\n\n\nThe definition of \nmin_instance_count\n and \nmax_instance_count\n can be found in the latter section. The desirable scaling instances are calculated differently for different types of apps as follow:\n\n\nDelivery workers\n\n\nThe autoscaler checks the total number of messages in the queues (ApproximateNumberOfMessages) of the app and scaled accordingly. One app can use multiple queues. This scaling is applicable to database tasks, CSV job processor, notifications senders and various research and priority jobs. \n\n\nFor example, \n\nnotify-delivery-worker-sender\n is an app for delivering the notifications to the service providers, i.e. AWS SES and text messaging providers. The celery worker consumes tasks from two queues: \nsend-sms-tasks\n and \nsend-sms-tasks\n are being monitored. The number of instances is then calculated as:-\n\n\ndesired_instances_count = total_message_count / request_per_instance\n\n\n\n\nwhere \ntotal_message_count\n is the sum of all the queues of this app and \nrequest_per_instance\n is a predefined estimated number of tasks an app instance can handle at one time.\n\n\nRequest handlers\n\n\nThe inbound apps are scaled based on last 5 \nrequest_counts\n, where \nrequest_counts\n is the total number of incoming requests in one minute.  \n\n\ndesired_instance_count = max(request_counts)/request_per_instance\n\n\n\n\nrequest_per_instance\n is a pre-defined scaler that indicates the number of requests that can be handled by one instance of app. \n\n\nScheduled jobs\n\n\nNotify uses a proactive schedule for scheduled tasks. Scheduled tasks are CSV files the users uploaded to be run at a given time. We already have the information of job size (number of notifications) and the scheduled time. The proactive scheduler scales up the number of instances before the jobs start. This scaling applies to the same apps as the Delivery workers above. \n\n\nThe desired number of instances for the particular app is calculated as follow:\n\n\ndesired_instance_count=num_of_scheduled_jobs/request_per_instance/scheduled_job_scaling_factor\nand\nmin_instance_count\n=desired_instances_count\n=max_instance_count\n\n\n\n\nThe \nnum_of_scheduled_jobs\n is the number of notifications to be sent in that job. \nRequest_per_instance\n gives a first indication on the number of tasks that can be handled by one app instance. We can use \nscheduled_job_scaling_factor\n to control how aggressively we want the scaling to be. Currently, this factor is set to 2 in Notify. Moreover, as the tasks are first delivered to the queues by delivery worker before these queues are consumed by senders and database workers. Hence, they are scaled up less agressively. \n\n\nThe Scaling function\n\n\nThe function \nscale_paas_apps\n uses the \ndesired_instance_count\n factor calculated to scale up or down the number of instances for the app. Below is the Psuedocode for the autoscaler. \n\n\nif desired_instance_count \n current_instance_count\n    scale up to desired_instance_count\nelse if time since last scale up \n 5 mins\n    current_instance_count = current_instance_count - 1\n\n\n\n\nThe apps are instantly scaled up to the \ndesired_instance_count\n if the current number of running instances is lower. However, on scaling down, No apps are scaled down if there has been a scaling up event in any app in the last 5 mins.  \n\n\nIn a cooling down period, we only specify how many instances an app has. We do not specify which instance to kill. Any instance can be killed at scaling down. \n\n\nFor Example,\n\n\n\n\nInitial instances: A, B, C\n\n\nInstances after scale up: A, B, C, D, E\n\n\nPossible state after scale down: B, C, E\n\n\n\n\nMin and max instance counts\n\n\nThe \nmin_instance_count\n and \nmax_instance_count\n used to bound the \ndesired_instance_count\n is defined differently in Notify's environment as below:\n\n\n\n\n\n\n\n\nApp(delivery)\n\n\nQueues\n\n\nMsg per instance\n\n\nDefault in prod\n\n\nPreview\n\n\nStaging/ Prod\n\n\n\n\n\n\n\n\n\n\nnotify-delivery-worker-sender\n\n\nsend-sms, send-email, send-tasks\n\n\n250\n\n\n4\n\n\n1-2\n\n\n4-20\n\n\n\n\n\n\nnotify-delivery-worker\n\n\nnotify, retry, process-job, notify-internal-tasks, retry-tasks, job-tasks, periodic-tasks\n\n\n250\n\n\n2\n\n\n1-1\n\n\n2-5\n\n\n\n\n\n\nnotify-delivery-worker-database\n\n\ndb-sms, db-email, db-letter, database-tasks\n\n\n250\n\n\n2\n\n\n1-2\n\n\n2-20\n\n\n\n\n\n\nnotify-delivery-worker-periodic\n\n\nperiodic, statistics, periodic-tasks, statistics-tasks\n\n\n250\n\n\n2\n\n\n1-1\n\n\n2-5\n\n\n\n\n\n\nnotify-delivery-worker-research\n\n\nresearch-mode, research-mode-tasks\n\n\n250\n\n\n2\n\n\n1-1\n\n\n2-5\n\n\n\n\n\n\nnotify-delivery-worker-priority\n\n\npriority, priority-tasks\n\n\n250\n\n\n2\n\n\n1-1\n\n\n2-5\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nApp (Inbound)\n\n\nQueues\n\n\nReq per instance\n\n\nDefault in prod\n\n\nPreview\n\n\nStaging/ Prod\n\n\n\n\n\n\n\n\n\n\nnotify-api\n\n\nnotify-paas-proxy\n\n\n1500\n\n\n4\n\n\n1-2\n\n\n2-20\n\n\n\n\n\n\n\n\nNon-scaled apps\n\n\nThe following apps are not scaled:\n\n\n\n\nnotify-delivery-celery-beat (default: 2)\n\n\nnotify-admin-failwhale (default: 1)\n\n\nnotify-template-preview (default: 1)\n\n\nnotify-admin (default: 2)\n\n\n\n\nSource Code\n\n\nThe source code of our autoscaler can be found \nhere\n in the Notify's \nnotificaitos-paas-autoscaler\n repository.", 
            "title": "Autoscaling"
        }, 
        {
            "location": "/autoscaling/#govuk-notify-autoscaler", 
            "text": "Notify has bursty, periodic loads and traffic. Outside of that, the traffic stays low and, most of the time, it consists of scheduled test jobs.; and twe get more traffic during office hours. Once in a while, we would receive a task that is consisted of  20k notifications. This has motivated us to develop an autoscaler to response to these tasks and scale up and down Notify apps instances running on PaaS.   These terms used in this article refer to:   a  job  is used to describe when a user uploads a csv file that consists of a batch of notifications to be sent   a  task  is a unit of notification, database query or a process to be run on the servers at a time  a  request  describes an 'http request' to retrieve or process information.", 
            "title": "GOV.UK Notify AutoScaler"
        }, 
        {
            "location": "/autoscaling/#metrics", 
            "text": "Notify's auto scaling uses these metrics:    RequestCounts (for Request handlers)   \nA metric returned by AWS Cloudwatch for the Elastic Load Balancers (ELB) to scale each of the ELB apps running on PaaS    ApproximateNumberOfMessages (for Delivery workers)   \nA metric returned by AWS Cloudwatch for the SQS queues to scale each notification delivery and database apps on PaaS.    Number of scheduled notifications (for Scheduled jobs) \nA metric obtained from the database for csv files to be sent in the next 1 minutes, and is updated everytime when the autoscaler is scheduled run.    The autoscaler is scheduled to run every 20 seconds using the python  sched  module. Autoscaling applies to each individual apps.", 
            "title": "Metrics"
        }, 
        {
            "location": "/autoscaling/#scaling-instances", 
            "text": "A factor  desired_instances_count  is used to determine the desired number of instances to run for an App at an evaluated period. This factor is calculated differently for our three types of apps and is bounded by:  min_instance_count =desired_instances_count =max_instance_count  The definition of  min_instance_count  and  max_instance_count  can be found in the latter section. The desirable scaling instances are calculated differently for different types of apps as follow:", 
            "title": "Scaling instances"
        }, 
        {
            "location": "/autoscaling/#delivery-workers", 
            "text": "The autoscaler checks the total number of messages in the queues (ApproximateNumberOfMessages) of the app and scaled accordingly. One app can use multiple queues. This scaling is applicable to database tasks, CSV job processor, notifications senders and various research and priority jobs.   For example,  notify-delivery-worker-sender  is an app for delivering the notifications to the service providers, i.e. AWS SES and text messaging providers. The celery worker consumes tasks from two queues:  send-sms-tasks  and  send-sms-tasks  are being monitored. The number of instances is then calculated as:-  desired_instances_count = total_message_count / request_per_instance  where  total_message_count  is the sum of all the queues of this app and  request_per_instance  is a predefined estimated number of tasks an app instance can handle at one time.", 
            "title": "Delivery workers"
        }, 
        {
            "location": "/autoscaling/#request-handlers", 
            "text": "The inbound apps are scaled based on last 5  request_counts , where  request_counts  is the total number of incoming requests in one minute.    desired_instance_count = max(request_counts)/request_per_instance  request_per_instance  is a pre-defined scaler that indicates the number of requests that can be handled by one instance of app.", 
            "title": "Request handlers"
        }, 
        {
            "location": "/autoscaling/#scheduled-jobs", 
            "text": "Notify uses a proactive schedule for scheduled tasks. Scheduled tasks are CSV files the users uploaded to be run at a given time. We already have the information of job size (number of notifications) and the scheduled time. The proactive scheduler scales up the number of instances before the jobs start. This scaling applies to the same apps as the Delivery workers above.   The desired number of instances for the particular app is calculated as follow:  desired_instance_count=num_of_scheduled_jobs/request_per_instance/scheduled_job_scaling_factor\nand\nmin_instance_count =desired_instances_count =max_instance_count  The  num_of_scheduled_jobs  is the number of notifications to be sent in that job.  Request_per_instance  gives a first indication on the number of tasks that can be handled by one app instance. We can use  scheduled_job_scaling_factor  to control how aggressively we want the scaling to be. Currently, this factor is set to 2 in Notify. Moreover, as the tasks are first delivered to the queues by delivery worker before these queues are consumed by senders and database workers. Hence, they are scaled up less agressively.", 
            "title": "Scheduled jobs"
        }, 
        {
            "location": "/autoscaling/#the-scaling-function", 
            "text": "The function  scale_paas_apps  uses the  desired_instance_count  factor calculated to scale up or down the number of instances for the app. Below is the Psuedocode for the autoscaler.   if desired_instance_count   current_instance_count\n    scale up to desired_instance_count\nelse if time since last scale up   5 mins\n    current_instance_count = current_instance_count - 1  The apps are instantly scaled up to the  desired_instance_count  if the current number of running instances is lower. However, on scaling down, No apps are scaled down if there has been a scaling up event in any app in the last 5 mins.    In a cooling down period, we only specify how many instances an app has. We do not specify which instance to kill. Any instance can be killed at scaling down.   For Example,   Initial instances: A, B, C  Instances after scale up: A, B, C, D, E  Possible state after scale down: B, C, E", 
            "title": "The Scaling function"
        }, 
        {
            "location": "/autoscaling/#min-and-max-instance-counts", 
            "text": "The  min_instance_count  and  max_instance_count  used to bound the  desired_instance_count  is defined differently in Notify's environment as below:     App(delivery)  Queues  Msg per instance  Default in prod  Preview  Staging/ Prod      notify-delivery-worker-sender  send-sms, send-email, send-tasks  250  4  1-2  4-20    notify-delivery-worker  notify, retry, process-job, notify-internal-tasks, retry-tasks, job-tasks, periodic-tasks  250  2  1-1  2-5    notify-delivery-worker-database  db-sms, db-email, db-letter, database-tasks  250  2  1-2  2-20    notify-delivery-worker-periodic  periodic, statistics, periodic-tasks, statistics-tasks  250  2  1-1  2-5    notify-delivery-worker-research  research-mode, research-mode-tasks  250  2  1-1  2-5    notify-delivery-worker-priority  priority, priority-tasks  250  2  1-1  2-5        App (Inbound)  Queues  Req per instance  Default in prod  Preview  Staging/ Prod      notify-api  notify-paas-proxy  1500  4  1-2  2-20", 
            "title": "Min and max instance counts"
        }, 
        {
            "location": "/autoscaling/#non-scaled-apps", 
            "text": "The following apps are not scaled:   notify-delivery-celery-beat (default: 2)  notify-admin-failwhale (default: 1)  notify-template-preview (default: 1)  notify-admin (default: 2)", 
            "title": "Non-scaled apps"
        }, 
        {
            "location": "/autoscaling/#source-code", 
            "text": "The source code of our autoscaler can be found  here  in the Notify's  notificaitos-paas-autoscaler  repository.", 
            "title": "Source Code"
        }
    ]
}